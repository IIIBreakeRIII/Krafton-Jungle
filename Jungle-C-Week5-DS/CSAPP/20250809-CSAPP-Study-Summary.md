# CSAPP 스터디 세션 요약 (65분)

## 1. 해저드(Hazard) 복습 및 제어 해저드 회피
- 이전 세션에서 해저드의 개념과 종류, 회피 방법 복습.
  - 데이터 해저드, 구조적 해저드, 제어 해저드 구분.
  - 특히 로드-사용 데이터 해저드(load-use hazard)의 경우 단순 포워딩만으로 해결 불가 → 버블 삽입 필요.
- 이번 시작 부분은 **제어 해저드(Control Hazard)** 회피.
  - 주로 `ret` 명령어나 분기·점프 명령어에서 발생.
  - 예: 함수 호출 후 복귀 주소를 알기 전까지 올바른 다음 명령어 패치를 할 수 없는 상황.
- 기본 회피 방식: 일단 분기·점프를 수행하고, 잘못된 경우 해당 경로의 명령어 취소(flushing).
  - 잘못 예측한 경우, 해당 명령어를 전부 무효화 → 불필요한 클럭 낭비.

## 2. 예외 처리(Exceptions)와 파이프라인에서의 특수성
- 예외 발생 원인
  - **내부적**: `halt` 명령, 잘못된 명령어/함수 코드 조합, 유효하지 않은 메모리 주소 접근 등.
  - **외부적**: I/O 동작, 다른 하드웨어 호출 시 발생 가능.
- 파이프라인 환경에서의 예외 처리 시 주의점
  1. **다중 예외 발생**: 한 사이클 내 서로 다른 단계에서 복수 예외 발생 가능 → 진행이 더 앞선 단계의 예외를 우선 처리.
  2. **분기 예측과 잘못된 예외**: 분기 예측에 의해 가져온 명령어가 나중에 취소되면 해당 예외도 함께 폐기.
  3. **다단계 상태 갱신 문제**: 예외 확정 전에 일부 상태 변경이 일어나면 안 됨.
- 해결 방법
  - 각 명령어에 상태 코드 필드(`status`)를 두어 단계별 진행 상태 기록.
  - `Write Back` 단계에서 예외 감지 후 프로그램 상태를 보고.
  - 예외 이후의 명령어는 프로그래머가 볼 수 있는 상태(레지스터, 메모리)에 변경 불가.

## 3. Y86-64 파이프라인 단계별 동작
- **Fetch 단계**: 명령어 바이트 읽기, 분해, 레지스터·상수·주소 산출, 다음 PC 결정.
- **Decode 단계**: 레지스터 읽기, `sel+fwd` 유닛을 통한 선택 및 포워딩 처리.
- **Execute 단계**: ALU 연산, 조건 코드(cc) 갱신, 분기 판정.
- **Memory 단계**: 메모리 읽기/쓰기, 주소 예외 감지.
- **Write Back 단계**: 레지스터 기록, 상태 코드 보고.
- 포워딩 규칙: 같은 레지스터를 여러 명령어가 갱신 시, 가장 최신의 값을 선택.

## 4. 파이프라인 제어 로직
- 처리해야 할 주요 특수 조건 (총 4가지)
  1. **Load-use hazard**: F, D 단계 스톨, E 단계 버블 삽입.
  2. **Return 명령 처리**: 올바른 복귀 주소 확보 전까지 F 단계 스톨, D 단계 버블.
  3. **잘못 예측한 분기**: D, E 단계 버블 삽입, 잘못된 명령어 제거.
  4. **예외 명령어 처리**: 이전 명령은 완료, 이후 명령은 상태 변경 금지, 메모리 쓰기 차단, 파이프라인 정지.
- 특수 조건 조합 처리:
  - A조합: Not-taken 분기 + Return → F 단계 스톨, D/E 버블.
  - B조합: Load-use hazard + Return → Load-use 우선 처리, Return 한 사이클 지연.

## 5. 성능 분석
- CPI(Cycles Per Instruction)
  - 이상적 CPI = 1.0
  - 실제 CPI = 1.0 + (버블 사이클 수 / 명령어 수)
- 버블 발생 요인 및 페널티
  - Load-use hazard → 버블 1개
  - 분기 오예측 → 버블 2개
  - Return → 버블 3개
- 분기 예측 정확도 향상이 성능 개선에 가장 큰 효과.

## 6. 파이프라인 확장: 실용적 고려사항
- **다중사이클 연산**: 곱셈, 나눗셈, 부동소수점 연산 등은 전용 기능 유닛 사용하여 메인 파이프라인과 병렬 실행.
- **메모리 시스템 현실화**
  - 캐시 계층 구조 반영, 캐시 미스 시 지연 처리.
  - 페이지 폴트 발생 시 OS 예외 처리 루틴 호출 → 디스크 접근 후 재시작.

## 7. 코드 최적화 개요
- 프로그램 성능 개선 요소
  1. 적절한 알고리즘·자료구조 선택
  2. 최적화 수준이 적절한 컴파일러 사용
  3. 불필요한 메모리 참조 제거
- 최적화를 방해하는 요소
  - 메모리 별칭(aliasing) 문제
  - 함수 호출에 따른 부수효과(side effect)
- 루프 언롤링(loop unrolling) 기법: 반복문 내 연산을 여러 번 펼쳐 실행하여 CPE 감소.
- 벡터 자료구조 예제:
  - 동적 크기 관리, 포인터와 데이터 배열의 추상화.

## 8. 비효율적 코드 예제와 개선 방향
- 불필요한 인덱스 검사, 중복 메모리 접근, 불필요한 함수 호출 제거.
- 개선 후 불필요한 연산 감소, 캐시 효율 증가.

---
**총평**: 이번 세션에서는 Y86-64 파이프라인의 제어 해저드와 예외 처리, 성능 분석 방법, 그리고 코드 최적화 기법까지 폭넓게 다룸. 하드웨어·소프트웨어 모두에서 병목을 줄이는 전략이 중요함을 재확인.
